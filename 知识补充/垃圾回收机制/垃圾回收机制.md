# Garbage Collection 机制

## 什么是垃圾

程序不用的内存就是垃圾

## 垃圾回收

把不用的内存释放掉就是垃圾回收、而在浏览器引擎中有一套机制帮助我们回收垃圾、这就是垃圾回收机制

## 垃圾产生

我们写程序时会定义很多函数，变量。这些东西都是需要内存的、如果太多了浏览器受不了就需要回收

## 垃圾回收策略

策略就是找到“垃圾”，释放“垃圾内存”

找到“垃圾”的两个方法：

- 标记清除法
- 引用计数法

## 标记清除法

大多数浏览器的 `JavaScript引擎` 都在采用标记清除算法、只是各大厂商对这个算法进行了优化；

此算法分为 `标记` 和 `清除` 两个阶段，**标记阶段即为所有活动对象做上标记**，**清除阶段则把没有标记（也就是非活动对象）销毁**；

引擎在执行 GC（使用标记清除算法）时，需要**从出发点去遍历内存中所有的对象去打标记**，而这个**出发点有很多**，我们称之为一组 `根` 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 `全局Window对象`、`文档DOM树` 等

执行步骤如下：

1. 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
2. 从各个根对象开始遍历，把不是垃圾的节点改成1
3. 所有标记为0的垃圾，销毁并回收它们所占用的内存空间
4. 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收



## 引用计数法

这个算法问题很多、但还是了解下；它的执行步骤如下

1. 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
2. 如果同一个值又被赋给另一个变量，那么引用数加 1
3. 如果该变量的值被其他的值覆盖了，则引用次数减 1
4. 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存

**引用计数有一个问题**

循环引用、内存永远不会清除

```js
function test(){
  let A = new Object()
  let B = new Object()
  
  A.b = B
  B.a = A
}
```

